generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                      String                   @id @default(cuid())
  email                   String                   @unique
  passwordHash            String?
  userType                UserType
  approvalStatus          ApprovalStatus           @default(PENDING)
  phoneVerified           Boolean                  @default(false)
  isActive                Boolean                  @default(true)
  lastLogin               DateTime?
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  
  // NextAuth.js OAuth fields
  name                    String?
  image                   String?
  emailVerified           DateTime?
  
  // NextAuth.js relations
  accounts                Account[]
  sessions                Session[]
  reservations            BookingReservation[]     @relation("ParentReservations")
  caregiverBookings       Booking[]                @relation("CaregiverBookings")
  parentBookings          Booking[]                @relation("ParentBookings")
  caregiver               Caregiver?
  caregiverChatRooms      ChatRoom[]               @relation("CaregiverChatRooms")
  parentChatRooms         ChatRoom[]               @relation("ParentChatRooms")
  children                Child[]
  emergencyContacts       EmergencyContact[]
  manualPayouts           ManualPayout[]
  sentMessages            Message[]
  notificationPreferences NotificationPreferences?
  notifications           Notification[]
  receivedReviews         Review[]                 @relation("ReviewReceiver")
  givenReviews            Review[]                 @relation("ReviewGiver")
  profile                 UserProfile?

  @@map("users")
}

model UserProfile {
  id                String    @id @default(cuid())
  userId            String    @unique
  firstName         String
  lastName          String
  phone             String?
  avatar            String?
  dateOfBirth       DateTime?
  streetAddress     String?
  city              String?
  state             String?
  zipCode           String?
  country           String    @default("US")
  latitude          Float?
  longitude         Float?
  emergencyName     String?
  emergencyPhone    String?
  emergencyRelation String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  apartment         String?
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model Caregiver {
  id                   String                   @id @default(cuid())
  userId               String                   @unique
  hourlyRate           Float
  experienceYears      Int                      @default(0)
  bio                  String?
  languages            Json?
  availability         Json?
  maxChildren          Int                      @default(3)
  minAge               Int                      @default(0)
  maxAge               Int                      @default(144)
  dailyCapacity        Int                      @default(6)
  enableDynamicPricing Boolean                  @default(false)
  capacityThresholds   Json?
  isVerified           Boolean                  @default(false)
  backgroundCheck      Boolean                  @default(false)
  backgroundCheckDate  DateTime?
  stripeAccountId      String?
  stripeOnboarded      Boolean                  @default(false)
  canReceivePayments   Boolean                  @default(false)
  totalBookings        Int                      @default(0)
  averageRating        Float?
  totalEarnings        Int                      @default(0)
  isAvailable          Boolean                  @default(true)
  lastActiveAt         DateTime                 @default(now())
  createdAt            DateTime                 @default(now())
  updatedAt            DateTime                 @updatedAt
  availabilitySlots    AvailabilitySlot[]
  bookings             Booking[]                @relation("CaregiverBookings")
  certifications       CaregiverCertification[]
  photos               CaregiverPhoto[]
  services             CaregiverService[]
  verification         CaregiverVerification?
  user                 User                     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("caregivers")
}

model CaregiverCertification {
  id             String            @id @default(cuid())
  caregiverId    String
  type           CertificationType
  title          String
  issuingBody    String
  issueDate      DateTime
  expirationDate DateTime?
  certificateUrl String?
  isVerified     Boolean           @default(false)
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  caregiver      Caregiver         @relation(fields: [caregiverId], references: [id], onDelete: Cascade)

  @@map("caregiver_certifications")
}

model CaregiverService {
  id          String      @id @default(cuid())
  caregiverId String
  serviceType ServiceType
  rate        Float?
  description String?
  isOffered   Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  caregiver   Caregiver   @relation(fields: [caregiverId], references: [id], onDelete: Cascade)

  @@unique([caregiverId, serviceType])
  @@map("caregiver_services")
}

model CaregiverPhoto {
  id          String    @id @default(cuid())
  caregiverId String
  url         String
  caption     String?
  isProfile   Boolean   @default(false)
  sortOrder   Int       @default(0)
  createdAt   DateTime  @default(now())
  caregiver   Caregiver @relation(fields: [caregiverId], references: [id], onDelete: Cascade)

  @@map("caregiver_photos")
}

model Booking {
  id              String               @id @default(cuid())
  parentId        String
  caregiverId     String
  startTime       DateTime
  endTime         DateTime
  childrenCount   Int
  specialRequests String?
  address         String
  latitude        Float?
  longitude       Float?
  hourlyRate      Float
  totalHours      Float
  subtotal        Int
  platformFee     Int
  totalAmount     Int
  status          BookingStatus        @default(PENDING)
  requestedAt     DateTime             @default(now())
  confirmedAt     DateTime?
  completedAt     DateTime?
  cancelledAt     DateTime?
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  reservations    BookingReservation[] @relation("BookingReservations")
  caregiverUser   User                 @relation("CaregiverBookings", fields: [caregiverId], references: [id])
  caregiverProfile Caregiver           @relation("CaregiverBookings", fields: [caregiverId], references: [userId])
  parent          User                 @relation("ParentBookings", fields: [parentId], references: [id])
  chatRoom        ChatRoom?
  checkInOuts     CheckInOut[]
  invoices        Invoice[]
  payments        Payment[]
  reviews         Review?
  slotBookings    SlotBooking[]        @relation("SlotBookings")

  @@map("bookings")
}

model Payment {
  id                    String        @id @default(cuid())
  bookingId             String
  stripePaymentIntentId String        @unique
  stripeChargeId        String?
  amount                Int
  platformFee           Int
  caregiverPayout       Int
  status                PaymentStatus @default(PENDING)
  paymentMethod         Json?
  receiptUrl            String?
  failureReason         String?
  paidAt                DateTime?
  refundedAt            DateTime?
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  booking               Booking       @relation(fields: [bookingId], references: [id])

  @@map("payments")
}

model Invoice {
  id             String        @id @default(cuid())
  bookingId      String
  invoiceNumber  String        @unique
  type           InvoiceType
  recipientEmail String
  recipientName  String
  amount         Int
  status         InvoiceStatus @default(DRAFT)
  issueDate      DateTime      @default(now())
  dueDate        DateTime
  paidDate       DateTime?
  pdfUrl         String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  booking        Booking       @relation(fields: [bookingId], references: [id])

  @@map("invoices")
}

model Review {
  id             String    @id @default(cuid())
  bookingId      String    @unique
  reviewerId     String
  revieweeId     String
  rating         Int
  comment        String?
  isApproved     Boolean   @default(false)
  moderatedAt    DateTime?
  moderatorNotes String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  reviewee       User      @relation("ReviewReceiver", fields: [revieweeId], references: [id])
  reviewer       User      @relation("ReviewGiver", fields: [reviewerId], references: [id])
  booking        Booking   @relation(fields: [bookingId], references: [id])

  @@map("reviews")
}

model Notification {
  id           String    @id @default(cuid())
  userId       String
  type         String
  title        String
  message      String
  isRead       Boolean   @default(false)
  readAt       DateTime?
  resourceType String?
  resourceId   String?
  createdAt    DateTime  @default(now())
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model ManualPayout {
  id              String    @id @default(cuid())
  caregiverId     String
  amount          Int
  method          String
  notes           String?
  bookingIds      String
  status          String    @default("PENDING")
  processedAt     DateTime?
  confirmedAt     DateTime?
  referenceNumber String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  caregiver       User      @relation(fields: [caregiverId], references: [id])

  @@map("manual_payouts")
}

model Setting {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("settings")
}

model ChatRoom {
  id            String    @id @default(cuid())
  bookingId     String    @unique
  parentId      String
  caregiverId   String
  isActive      Boolean   @default(true)
  lastMessageAt DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  caregiver     User      @relation("CaregiverChatRooms", fields: [caregiverId], references: [id])
  parent        User      @relation("ParentChatRooms", fields: [parentId], references: [id])
  booking       Booking   @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  messages      Message[]

  @@map("chat_rooms")
}

model Message {
  id          String      @id @default(cuid())
  chatRoomId  String
  senderId    String
  content     String
  messageType MessageType @default(TEXT)
  isRead      Boolean     @default(false)
  readAt      DateTime?
  createdAt   DateTime    @default(now())
  sender      User        @relation(fields: [senderId], references: [id])
  chatRoom    ChatRoom    @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)

  @@map("messages")
}

model Child {
  id                   String       @id @default(cuid())
  parentId             String
  firstName            String
  lastName             String
  dateOfBirth          DateTime
  gender               String?
  allergies            Json?
  medications          Json?
  medicalConditions    Json?
  emergencyMedicalInfo String?
  bloodType            String?
  emergencyContacts    Json?
  dietaryRestrictions  Json?
  specialInstructions  String?
  pickupInstructions   String?
  photoUrl             String?
  createdAt            DateTime     @default(now())
  updatedAt            DateTime     @updatedAt
  checkIns             CheckInOut[]
  parent               User         @relation(fields: [parentId], references: [id], onDelete: Cascade)

  @@map("children")
}

model CheckInOut {
  id               String           @id @default(cuid())
  bookingId        String
  childId          String
  caregiverId      String
  checkInTime      DateTime?
  checkInPhotoUrl  String?
  checkInNotes     String?
  checkInLocation  Json?
  checkOutTime     DateTime?
  checkOutPhotoUrl String?
  checkOutNotes    String?
  checkOutLocation Json?
  status           CheckInOutStatus @default(PENDING)
  activities       Json?
  meals            Json?
  napTime          Json?
  behaviorNotes    String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  child            Child            @relation(fields: [childId], references: [id], onDelete: Cascade)
  booking          Booking          @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@map("check_in_outs")
}

model EmergencyContact {
  id               String   @id @default(cuid())
  userId           String
  name             String
  relationship     String
  phoneNumber      String
  email            String?
  address          String?
  priority         Int      @default(1)
  canPickup        Boolean  @default(false)
  canMakeDecisions Boolean  @default(false)
  notes            String?
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("emergency_contacts")
}

model CaregiverVerification {
  id                       String             @id @default(cuid())
  caregiverId              String             @unique
  idVerificationStatus     VerificationStatus @default(PENDING)
  idDocumentUrl            String?
  idVerifiedAt             DateTime?
  idVerifiedBy             String?
  backgroundCheckStatus    VerificationStatus @default(PENDING)
  backgroundCheckProvider  String?
  backgroundCheckDate      DateTime?
  backgroundCheckReportUrl String?
  insuranceStatus          VerificationStatus @default(PENDING)
  insuranceProvider        String?
  insurancePolicyNumber    String?
  insuranceExpiryDate      DateTime?
  insuranceDocumentUrl     String?
  referencesStatus         VerificationStatus @default(PENDING)
  references               Json?
  overallStatus            VerificationStatus @default(PENDING)
  verificationScore        Int?
  createdAt                DateTime           @default(now())
  updatedAt                DateTime           @updatedAt
  caregiver                Caregiver          @relation(fields: [caregiverId], references: [id], onDelete: Cascade)

  @@map("caregiver_verifications")
}

model AvailabilitySlot {
  id                  String               @id @default(cuid())
  caregiverId         String
  date                DateTime
  startTime           DateTime
  endTime             DateTime
  totalCapacity       Int
  currentOccupancy    Int                  @default(0)
  availableSpots      Int
  baseRate            Float
  currentRate         Float
  status              SlotStatus           @default(AVAILABLE)
  isRecurring         Boolean              @default(false)
  recurringPattern    Json?
  specialRequirements Json?
  notes               String?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  caregiver           Caregiver            @relation(fields: [caregiverId], references: [id], onDelete: Cascade)
  reservations        BookingReservation[]
  slotBookings        SlotBooking[]

  @@unique([caregiverId, date, startTime])
  @@index([caregiverId, date])
  @@index([date, status])
  @@map("availability_slots")
}

model BookingReservation {
  id            String            @id @default(cuid())
  slotId        String
  parentId      String
  childrenCount Int
  reservedSpots Int
  status        ReservationStatus @default(ACTIVE)
  expiresAt     DateTime
  bookingId     String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  booking       Booking?          @relation("BookingReservations", fields: [bookingId], references: [id])
  parent        User              @relation("ParentReservations", fields: [parentId], references: [id])
  slot          AvailabilitySlot  @relation(fields: [slotId], references: [id], onDelete: Cascade)

  @@index([parentId])
  @@index([status, expiresAt])
  @@map("booking_reservations")
}

model SlotBooking {
  id            String           @id @default(cuid())
  slotId        String
  bookingId     String
  childrenCount Int
  spotsUsed     Int
  rateApplied   Float
  createdAt     DateTime         @default(now())
  booking       Booking          @relation("SlotBookings", fields: [bookingId], references: [id], onDelete: Cascade)
  slot          AvailabilitySlot @relation(fields: [slotId], references: [id], onDelete: Cascade)

  @@unique([slotId, bookingId])
  @@map("slot_bookings")
}

model NotificationEvent {
  id               String                @id @default(cuid())
  type             NotificationType
  channel          NotificationChannel
  templateId       String
  priority         NotificationPriority  @default(NORMAL)
  recipientId      String?
  recipientEmail   String?
  recipientPhone   String?
  recipientName    String?
  subject          String?
  content          String
  htmlContent      String?
  status           NotificationStatus    @default(PENDING)
  deliveryStatus   DeliveryStatus?
  scheduledAt      DateTime?
  sentAt           DateTime?
  deliveredAt      DateTime?
  failedAt         DateTime?
  openedAt         DateTime?
  clickedAt        DateTime?
  providerId       String?
  providerData     Json?
  retryCount       Int                   @default(0)
  maxRetries       Int                   @default(3)
  nextRetryAt      DateTime?
  errorCode        String?
  errorMessage     String?
  errorDetails     Json?
  isTransactional  Boolean               @default(true)
  consentId        String?
  unsubscribeToken String?
  contextType      String?
  contextId        String?
  triggeredBy      String?
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  retries          NotificationRetry[]
  webhooks         NotificationWebhook[]

  @@index([recipientEmail, status])
  @@index([recipientPhone, status])
  @@index([status, scheduledAt])
  @@index([contextType, contextId])
  @@index([type, channel, createdAt])
  @@map("notification_events")
}

model NotificationRetry {
  id               String             @id @default(cuid())
  notificationId   String
  attemptNumber    Int
  status           NotificationStatus
  errorCode        String?
  errorMessage     String?
  errorDetails     Json?
  providerId       String?
  providerResponse Json?
  attemptedAt      DateTime           @default(now())
  notification     NotificationEvent  @relation(fields: [notificationId], references: [id], onDelete: Cascade)

  @@map("notification_retries")
}

model NotificationWebhook {
  id              String             @id @default(cuid())
  notificationId  String?
  provider        String
  providerId      String
  eventType       String
  rawPayload      Json
  signature       String?
  processed       Boolean            @default(false)
  processedAt     DateTime?
  processingError String?
  receivedAt      DateTime           @default(now())
  notification    NotificationEvent? @relation(fields: [notificationId], references: [id])

  @@index([provider, providerId])
  @@index([processed, receivedAt])
  @@map("notification_webhooks")
}

model NotificationTemplate {
  id              String               @id @default(cuid())
  templateId      String               @unique
  name            String
  description     String?
  type            NotificationType
  channel         NotificationChannel
  subject         String?
  textContent     String
  htmlContent     String?
  variables       Json?
  isActive        Boolean              @default(true)
  isTransactional Boolean              @default(true)
  priority        NotificationPriority @default(NORMAL)
  requiresConsent Boolean              @default(false)
  retentionDays   Int?
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt

  @@map("notification_templates")
}

model NotificationPreferences {
  id               String    @id @default(cuid())
  userId           String    @unique
  emailEnabled     Boolean   @default(true)
  marketingEmails  Boolean   @default(false)
  smsEnabled       Boolean   @default(true)
  marketingSms     Boolean   @default(false)
  bookingUpdates   Boolean   @default(true)
  paymentAlerts    Boolean   @default(true)
  reminderAlerts   Boolean   @default(true)
  securityAlerts   Boolean   @default(true)
  emailConsent     DateTime?
  smsConsent       DateTime?
  unsubscribeToken String?   @unique
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

model NotificationSettings {
  id                 String   @id @default(cuid())
  emailProvider      String   @default("resend")
  smsProvider        String   @default("twilio")
  emailRateLimit     Int      @default(100)
  smsRateLimit       Int      @default(50)
  maxRetries         Int      @default(3)
  retryDelays        Json
  emergencyBypass    Boolean  @default(true)
  requireDoubleOptIn Boolean  @default(false)
  retentionDays      Int      @default(365)
  updatedAt          DateTime @updatedAt

  @@map("notification_settings")
}

enum UserType {
  PARENT
  CAREGIVER
  ADMIN
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  SUSPENDED
}

enum BookingStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  DISPUTED
}

enum PaymentStatus {
  PENDING
  PAID
  REFUNDED
  FAILED
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
}

enum InvoiceType {
  PARENT
  CAREGIVER
  PLATFORM
}

enum CertificationType {
  CPR
  FIRST_AID
  BACKGROUND_CHECK
  CHILDCARE_LICENSE
  EDUCATION
  ID_VERIFICATION
  INSURANCE_VERIFICATION
  OTHER
}

enum ServiceType {
  BABYSITTING
  NANNY
  DAYCARE
  AFTER_SCHOOL
  OVERNIGHT
  SPECIAL_NEEDS
  TUTORING
}

enum MessageType {
  TEXT
  SYSTEM
}

enum CheckInOutStatus {
  PENDING
  CHECKED_IN
  CHECKED_OUT
  COMPLETED
}

enum VerificationStatus {
  PENDING
  IN_PROGRESS
  APPROVED
  REJECTED
  EXPIRED
  REQUIRES_UPDATE
}

enum SlotStatus {
  AVAILABLE
  RESERVED
  BOOKED
  COMPLETED
  CANCELLED
}

enum ReservationStatus {
  ACTIVE
  EXPIRED
  CONVERTED_TO_BOOKING
  CANCELLED
}

enum NotificationType {
  BOOKING_REQUEST
  BOOKING_CONFIRMATION
  BOOKING_CANCELLED
  BOOKING_REMINDER
  PICKUP_REMINDER
  DROPOFF_CONFIRMATION
  PAYMENT_RECEIVED
  PAYMENT_FAILED
  VERIFICATION_CODE
  ACCOUNT_APPROVED
  SECURITY_ALERT
  EMERGENCY_ALERT
  REVIEW_REQUEST
  SYSTEM_MAINTENANCE
}

enum NotificationChannel {
  EMAIL
  SMS
  PUSH
  IN_APP
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

enum NotificationStatus {
  PENDING
  QUEUED
  SENDING
  SENT
  DELIVERED
  FAILED
  CANCELLED
}

enum DeliveryStatus {
  DELIVERED
  FAILED
  BOUNCED
  SPAM
  UNSUBSCRIBED
  OPENED
  CLICKED
}

// NextAuth.js required models
model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}
